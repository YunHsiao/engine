%{
  "techniques": [
    {
      "queue": "transparent",
      "lod": 0,
      "passes": [
        {
          "vert": "gizmo-vs",
          "frag": "gizmo-fs",
          "stage": "default",
          "cullMode": "none",
          "depthTest": false,
          "depthWrite": false,
          "blend": true,
          "blendEq": "add",
          "blendSrc": "srcAlpha",
          "blendDst": "oneMinusSrcAlpha",
          "blendAlphaEq": "add",
          "blendSrcAlpha": "one",
          "blendDstAlpha": "oneMinusSrcAlpha"
        }
      ]
    }
  ],

  "properties": {
    "color": {
      "type": "color4",
      "value": [1, 1, 1, 1]
    }
  }
%}

%% gizmo-vs {
  attribute vec3 a_position;
  attribute vec3 a_normal;

  uniform mat4 model;
  uniform mat4 viewProj;
  uniform mat3 normalMatrix;

  varying vec3 normal_w;
  varying vec3 pos_w;
  varying vec3 pos_l;

  void main () {
    vec4 pos = vec4(a_position, 1);

    pos_l = a_position;
    pos_w = (model * pos).xyz;
    normal_w = normalMatrix * a_normal;

    gl_Position = viewProj * model * pos;
  }
}

%% gizmo-fs {
  #include <gamma-correction>
  #include <rect-area-light>

  uniform vec3 eye;
  uniform vec4 color;

  varying vec3 normal_w;
  varying vec3 pos_w;
  varying vec3 pos_l;

  #if PLANE_CONTROLLER
      #include <common>
      uniform float width;
      uniform float height;
      uniform float rotx;
      uniform float roty;
      uniform vec3 center;
      vec3 rotation_x(vec3 v, float a) {
          vec3 r;
          r.x =  v.x;
          r.y =  v.y*cos(a) - v.z*sin(a);
          r.z =  v.y*sin(a) + v.z*cos(a);
          return r;
      }
      vec3 rotation_y(vec3 v, float a) {
          vec3 r;
          r.x =  v.x*cos(a) + v.z*sin(a);
          r.y =  v.y;
          r.z = -v.x*sin(a) + v.z*cos(a);
          return r;
      }
      vec3 rotation_xy(vec3 v, float ax, float ay) {
          return rotation_y(rotation_x(v, ax), ay);
      }
      struct Rect {
          vec3  center;
          vec3  dirx;
          vec3  diry;
          float halfx;
          float halfy;
      };
      void InitRect(out Rect rect)
      {
          rect.center = center;
          rect.dirx = rotation_xy(vec3(1, 0, 0), rotx * PI2, roty * PI2);
          rect.diry = rotation_xy(vec3(0, 1, 0), rotx * PI2, roty * PI2);
          rect.halfx  = 0.5 * width;
          rect.halfy  = 0.5 * height;
      }
      void InitRectPoints(Rect rect, out vec3 points[4])
      {
          vec3 ex = rect.halfx * rect.dirx;
          vec3 ey = rect.halfy * rect.diry;

          points[0] = rect.center - ex - ey;
          points[1] = rect.center + ex - ey;
          points[2] = rect.center + ex + ey;
          points[3] = rect.center - ex + ey;
      }
  #endif

  void main () {
      vec3 N = normalize(normal_w);
      vec3 V = normalize(eye - pos_w);

      // vec3 L = normalize(vec3(1, 2, 3));
      // vec3 diffuse = color.rgb * (0.2 + max(0.0, dot(N, L)) * 0.8);

      vec3 points[4];
      #if PLANE_CONTROLLER
          Rect rect;
          InitRect(rect);
          InitRectPoints(rect, points);
      #else
          // { center: (30, 40, 50), width: 40, height: 40, rotx: -0.125, roty: 0.125 }
          points[0] = vec3(25.86, 25.86, 74.14);
          points[1] = vec3(54.14, 25.86, 45.86);
          points[2] = vec3(34.14, 54.14, 25.86);
          points[3] = vec3(5.86, 54.14, 54.14);
      #endif

      vec3 diffuse = color.rgb * (0.2 + LTC_Evaluate(N, V, pos_l, mat3(1), points) * 0.8);

      gl_FragColor = linearToGammaSpaceRGBA(vec4(diffuse, color.a));
  }
}
